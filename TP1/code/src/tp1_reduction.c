#include "../include/image.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>


// fin d'un fichier 
// nb = read (Desc , ... , taille)
// while (nb>0) ,alors le fichier est pas finit et continue d'etre lu

#define TAILLE_BUFFER 256
#define TAILLE_NOM 128

#define OK 1
#define KO -1

const char *MAGIC_NUMBER_STRING = "P5";

const char NL = '\n';
const char SPACE = ' ';

// une variable globale pour la lecture temporaire
char buffer[TAILLE_BUFFER];

//nom du fichier de l image
char pathfichierInput[TAILLE_BUFFER];
//nom du fichier de sortie de l image
char pathfichierOutput[TAILLE_BUFFER];

// variables globales
int largeur;
int longueur;
int niveau_gris;
int step = 0;

//fonctions internes au module
int traitement_arguments(int argc, char **argv);
void erreur();

//fonction main
int main(int argc, char **argv)
{
    //recuperer les arguments
    if (traitement_arguments(argc, argv) != OK)
    {
        erreur();
    }

    //ouvrir le fichier et retourner un descripteur
    int descripteurFichierEntree = open(pathfichierInput, O_RDONLY);
    printf("input file %s %d\n", pathfichierInput, descripteurFichierEntree);
    //ouvrir le fichier en ecriture
    int descripteurFichierSortie = open(pathfichierOutput, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    printf("ouput file %s %d\n", pathfichierOutput, descripteurFichierSortie);

    int sortir = 0;
    while (sortir == 0)
    {
        //traitement du contenu ici
        if (test_si_ligne_commentaire(descripteurFichierEntree) == OK)
        {
            lecture_Commentaire(descripteurFichierEntree);
        }
        else
        {
            //magic number
            if (lecture_MagicNumber(descripteurFichierEntree) != OK)
            {
                perror("magic number");
                erreur();
            }
            sortir = 1;
        }
    }

    ecriture_MagicNumber(descripteurFichierSortie);

    sortir = 0;
    while (sortir == 0)
    {
        //traitement du contenu ici
        if (test_si_ligne_commentaire(descripteurFichierEntree) == OK)
        {
            lecture_Commentaire(descripteurFichierEntree);
        }
        else
        {
            //magic number
            if (lecture_largeur_longueur(descripteurFichierEntree, &largeur, &longueur) != OK)
            {
                erreur();
            }
            sortir = 1;
        }
    }
    ecriture_largeur_longueur(descripteurFichierSortie);

    //programmation avec un style systeme
    while (1)
    {
        //traitement du contenu ici
        if (test_si_ligne_commentaire(descripteurFichierEntree) == OK)
        {
            lecture_Commentaire(descripteurFichierEntree);
        }
        else
        {
            //magic number
            if (lecture_NiveauGris(descripteurFichierEntree, &niveau_gris) != OK)
            {
                erreur();
            }
            break;
        }
    }

    ecriture_NiveauGris(descripteurFichierSortie);

    // maintenant les donnees
    while (1)
    {
        //traitement du contenu ici
        if (test_si_ligne_commentaire(descripteurFichierEntree) == OK)
        {
            lecture_Commentaire(descripteurFichierEntree);
        }
        else
        {
            //magic number
            if (traitement_Contenu(descripteurFichierEntree, descripteurFichierSortie) != OK)
            {
                erreur();
            }
            break;
        }
    }

    //fermeture du fichier entree
    close(descripteurFichierEntree);
}

//
int traitement_arguments(int argc, char **argv)
{
    if (argc < 3)
    {
        printf("nombre d'arguments insuffisant\n");
        exit(1);
    }
    strcpy(pathfichierInput, argv[1]);
    strcpy(pathfichierOutput, argv[2]);
    return OK;
}

//
//TODO. utilisation de off_t lseek(int fd, off_t offset, int whence);
int test_si_ligne_commentaire(int descripteurLecture)
{   
    char readchar;
    read(descripteurLecture, &readchar, sizeof(char));
    lseek(descripteurLecture, -1 , SEEK_CUR);
    if (readchar=='#'){
        return OK;
    }
    return KO;
};

//TODO
int avance_jusqua_nouvelle_ligne(int descripteurLecture)
{
    char readchar;
    while (read(descripteurLecture, &readchar, sizeof(char))){
        if (readchar=='\n'){
            return OK;
        }
    }
    return KO;
};

void lecture_Commentaire(int descripteurFichierEntree)
{
    avance_jusqua_nouvelle_ligne(descripteurFichierEntree);
};

//strcmp(const char *first, const char *second)

int lecture_MagicNumber(int descripteurLecture)
{
    char readChar;
    int index = 0;
    do
    {
        if (read(descripteurLecture, &readChar, sizeof(char)) == -1)
        {
            erreur();
            return KO;
        };

        buffer[index] = readChar;
        index++;
    } while (readChar != '\n' && index < TAILLE_BUFFER);
    //
    if (index < TAILLE_BUFFER)
    {
        index--;
        buffer[index] = '\0';
        if (strcmp(buffer, MAGIC_NUMBER_STRING) == 0)
        {
            return OK;
        }
        else
        {
            return KO;
        }
    }
    else
    {
        return KO;
    }
}

int ecriture_MagicNumber(int descripteurFichierSortie)
{
    write(descripteurFichierSortie, MAGIC_NUMBER_STRING, strlen(MAGIC_NUMBER_STRING));
    ecriture_NL(descripteurFichierSortie);
    return OK;
}

int ecriture_entier(int descripteur, int valeur)
{
    char digits[128];
    sprintf(digits, "%d", valeur);
    write(descripteur, digits, strlen(digits));
    return OK;
}

int ecriture_NL(int descripteur)
{
    write(descripteur, &NL, sizeof(char));
    return OK;
}

int ecriture_SPACE(int descripteur)
{
    write(descripteur, &SPACE, sizeof(char));
    return OK;
}

//TODO
int ecriture_largeur_longueur(int descripteurFichierSortie)
{
    ecriture_entier(descripteurFichierSortie,longueur/2);
    ecriture_SPACE(descripteurFichierSortie);
    ecriture_entier(descripteurFichierSortie,largeur/2);
    ecriture_NL(descripteurFichierSortie);
    return OK;
};

//TODO
int ecriture_NiveauGris(int descripteurFichierSortie)
{
   ecriture_entier(descripteurFichierSortie,niveau_gris);
   ecriture_NL(descripteurFichierSortie); 
   return OK;
};

//
int lecture_largeur_longueur(int descripteurLecture, int *largeur_ptr, int *longueur_ptr)
{
    char readChar;
    int index = 0;
    do
    {
        if (read(descripteurLecture, &readChar, sizeof(char)) == -1)
        {
            erreur();
            return KO;
        };

        buffer[index] = readChar;
        index++;
    } while (readChar != ' ' && index < TAILLE_BUFFER);

    if (index >= TAILLE_BUFFER)
    {
        return KO;
    }
    --index;
    buffer[index] = '\0';
    *largeur_ptr = atoi(buffer);

    index = 0;
    do
    {
        if (read(descripteurLecture, &readChar, sizeof(char)) == -1)
        {
            erreur();
            return KO;
        };

        buffer[index] = readChar;
        index++;
    } while (readChar != '\n' && index < TAILLE_BUFFER);

    if (index >= TAILLE_BUFFER)
    {
        return KO;
    }
    --index;
    buffer[index] = '\0';
    *longueur_ptr = atoi(buffer);

    printf("%d\n" ,*longueur_ptr);
    printf("%d\n" ,*largeur_ptr);
    return OK;
};

int lecture_NiveauGris(int descripteurLecture, int *niveau_gris_ptr)
{

    char readChar;
    int index = 0;
    do
    {
        if (read(descripteurLecture, &readChar, sizeof(char)) == -1)
        {
            erreur();
            return KO;
        };

        buffer[index] = readChar;
        index++;
    } while (readChar != '\n' && index < TAILLE_BUFFER);

    if (index >= TAILLE_BUFFER)
    {
        return KO;
    }
    --index;
    buffer[index] = '\0';
    *niveau_gris_ptr = atoi(buffer);
    return OK;
}

//TODO
int traitement_Contenu(int descripteurLecture, int descripteurSortie)
{
    char* npixel; char* apixel;
    int nbread;
    int m[longeur][largeur];
    do {
        nbread = read (descripteurLecture,buffer,sizeof(char)); 
        for (int i=0 ; i<longueur ; i++){
            for (int j=0; j<largeur; j++){
                m [i][j]= buffer;
            }
        }
        for (int i=0 ; i<longueur ; i++){
            for (int j=0; j<largeur; j++){
                npixel[i,j] = (m[2*i][2*j] + m[2*i][2*j +1] + m[2*i+1][2*j ] + m[2*i +1][2*j +1 ])/4 
        write(descripteurSortie,npixel,sizeof(char)); 
    }while (nbread > 0);
    return OK;
}

//fonction pour afficher un message d erreur et quitter l application
void erreur()
{
    printf("erreur");
    exit(1);
}